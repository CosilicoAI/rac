"""Rust code generator.

Compiles IR to Rust source code that can be built with cargo.
"""

from .. import ast
from ..compiler import IR, ResolvedVar


def generate_rust(ir: IR, module_name: str = "rules") -> str:
    """Generate Rust code from IR."""
    gen = RustGenerator(ir, module_name)
    return gen.generate()


class RustGenerator:
    """Generates Rust code from compiled IR."""

    def __init__(self, ir: IR, module_name: str):
        self.ir = ir
        self.module_name = module_name
        self.indent = 0

    def generate(self) -> str:
        """Generate complete Rust module."""
        lines = [
            "//! Auto-generated by RAC compiler",
            "",
            "use std::collections::HashMap;",
            "",
        ]

        # Generate entity structs
        for entity in self.ir.schema_.entities.values():
            lines.extend(self._gen_entity_struct(entity))
            lines.append("")

        # Generate context struct
        lines.extend(self._gen_context_struct())
        lines.append("")

        # Generate compute functions
        lines.extend(self._gen_compute_impl())

        return "\n".join(lines)

    def _gen_entity_struct(self, entity) -> list[str]:
        """Generate struct for an entity."""
        lines = [
            "#[derive(Debug, Clone)]",
            f"pub struct {self._rust_type_name(entity.name)} {{",
            "    pub id: i64,",
        ]

        for name, field in entity.fields.items():
            rust_type = self._field_type(field.dtype)
            lines.append(f"    pub {self._rust_ident(name)}: {rust_type},")

        for name, fk in entity.foreign_keys.items():
            lines.append(f"    pub {self._rust_ident(name)}: Option<i64>,")

        lines.append("}")
        return lines

    def _gen_context_struct(self) -> list[str]:
        """Generate context struct for execution."""
        lines = [
            "#[derive(Debug, Default)]",
            "pub struct Context {",
            "    pub scalars: HashMap<String, f64>,",
        ]

        for entity in self.ir.schema_.entities.values():
            type_name = self._rust_type_name(entity.name)
            lines.append(f"    pub {entity.name}s: Vec<{type_name}>,")

        lines.append("}")
        return lines

    def _gen_compute_impl(self) -> list[str]:
        """Generate compute implementation."""
        lines = [
            "impl Context {",
            "    pub fn compute(&mut self) {",
        ]

        for path in self.ir.order:
            var = self.ir.variables[path]
            lines.extend(self._gen_var_compute(var))

        lines.extend([
            "    }",
            "}",
        ])
        return lines

    def _gen_var_compute(self, var: ResolvedVar) -> list[str]:
        """Generate computation for a variable."""
        safe_path = self._rust_ident(var.path.replace("/", "_"))

        if var.entity is None:
            # Scalar
            expr_code = self._gen_expr(var.expr)
            return [
                f'        let {safe_path} = {expr_code};',
                f'        self.scalars.insert("{var.path}".to_string(), {safe_path});',
            ]
        else:
            # Entity-scoped
            expr_code = self._gen_expr(var.expr, entity_var="row")
            entity_plural = f"{var.entity}s"
            return [
                f"        for row in &self.{entity_plural} {{",
                f"            let _val = {expr_code};",
                f"            // TODO: store in entity results",
                "        }",
            ]

    def _gen_expr(self, expr: ast.Expr, entity_var: str | None = None) -> str:
        """Generate Rust expression."""
        match expr:
            case ast.Literal(value=v):
                if isinstance(v, bool):
                    return "true" if v else "false"
                if isinstance(v, str):
                    return f'"{v}"'
                if isinstance(v, float):
                    return f"{v}_f64"
                return f"{v}_f64"

            case ast.Var(path=path):
                if "/" in path:
                    safe = self._rust_ident(path.replace("/", "_"))
                    return safe
                if entity_var:
                    return f"{entity_var}.{self._rust_ident(path)}"
                return self._rust_ident(path)

            case ast.BinOp(op=op, left=left, right=right):
                l = self._gen_expr(left, entity_var)
                r = self._gen_expr(right, entity_var)
                rust_op = self._rust_op(op)
                return f"({l} {rust_op} {r})"

            case ast.UnaryOp(op=op, operand=operand):
                inner = self._gen_expr(operand, entity_var)
                if op == "-":
                    return f"(-{inner})"
                if op == "not":
                    return f"(!{inner})"
                return inner

            case ast.Call(func=func, args=args):
                arg_strs = [self._gen_expr(a, entity_var) for a in args]
                return self._gen_builtin_call(func, arg_strs)

            case ast.FieldAccess(obj=obj, field=field):
                obj_code = self._gen_expr(obj, entity_var)
                return f"{obj_code}.{self._rust_ident(field)}"

            case ast.Cond(condition=cond, then_expr=then_e, else_expr=else_e):
                c = self._gen_expr(cond, entity_var)
                t = self._gen_expr(then_e, entity_var)
                e = self._gen_expr(else_e, entity_var)
                return f"(if {c} {{ {t} }} else {{ {e} }})"

            case ast.Match(subject=subject, cases=cases, default=default):
                subj = self._gen_expr(subject, entity_var)
                arms = []
                for pattern, result in cases:
                    p = self._gen_expr(pattern, entity_var)
                    r = self._gen_expr(result, entity_var)
                    arms.append(f"{p} => {r}")
                if default:
                    d = self._gen_expr(default, entity_var)
                    arms.append(f"_ => {d}")
                else:
                    arms.append("_ => 0.0_f64")
                arms_str = ", ".join(arms)
                return f"(match {subj} {{ {arms_str} }})"

            case _:
                return "0.0_f64"

    def _gen_builtin_call(self, func: str, args: list[str]) -> str:
        """Generate builtin function call."""
        match func:
            case "min":
                if len(args) == 2:
                    return f"{args[0]}.min({args[1]})"
                return f"[{', '.join(args)}].iter().cloned().fold(f64::INFINITY, f64::min)"
            case "max":
                if len(args) == 2:
                    return f"{args[0]}.max({args[1]})"
                return f"[{', '.join(args)}].iter().cloned().fold(f64::NEG_INFINITY, f64::max)"
            case "abs":
                return f"{args[0]}.abs()"
            case "round":
                return f"{args[0]}.round()"
            case "sum":
                return f"{args[0]}.iter().sum::<f64>()"
            case "len":
                return f"({args[0]}.len() as f64)"
            case "clip":
                return f"{args[0]}.max({args[1]}).min({args[2]})"
            case _:
                return f"/* unknown: {func} */ 0.0_f64"

    def _rust_op(self, op: str) -> str:
        """Convert operator to Rust."""
        return {
            "and": "&&",
            "or": "||",
            "==": "==",
            "!=": "!=",
        }.get(op, op)

    def _rust_ident(self, name: str) -> str:
        """Make a valid Rust identifier."""
        # Replace invalid chars
        name = name.replace("-", "_").replace(".", "_")
        # Handle Rust keywords
        if name in ("type", "match", "fn", "let", "mut", "ref", "self", "super", "use"):
            return f"r#{name}"
        return name

    def _rust_type_name(self, name: str) -> str:
        """Convert entity name to Rust type name (PascalCase)."""
        return "".join(part.capitalize() for part in name.split("_"))

    def _field_type(self, dtype: str) -> str:
        """Convert field type to Rust type."""
        return {
            "int": "i64",
            "float": "f64",
            "str": "String",
            "bool": "bool",
            "date": "String",  # TODO: use chrono
        }.get(dtype, "f64")
