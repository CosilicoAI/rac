"""JavaScript code generator for Cosilico DSL.

Compiles parsed DSL modules to JavaScript that can run on:
- Cloudflare Workers (edge)
- Node.js
- Browser

Supports both scalar and vectorized (TypedArray) output.
"""

from dataclasses import dataclass, field
from typing import Optional

from .dsl_parser import (
    BinaryOp,
    Expression,
    FormulaBlock,
    FunctionCall,
    Identifier,
    IfExpr,
    LetBinding,
    Literal,
    MatchCase,
    MatchExpr,
    Module,
    ParameterRef,
    ReferencesBlock,
    UnaryOp,
    VariableDef,
    VariableRef,
)


# Operator mapping from DSL to JavaScript
BINARY_OPS = {
    "+": "+",
    "-": "-",
    "*": "*",
    "/": "/",
    "%": "%",
    "<": "<",
    ">": ">",
    "<=": "<=",
    ">=": ">=",
    "==": "===",
    "!=": "!==",
    "and": "&&",
    "or": "||",
}

UNARY_OPS = {
    "not": "!",
    "-": "-",
}

# Built-in function mapping
BUILTIN_FUNCTIONS = {
    "min": "Math.min",
    "max": "Math.max",
    "abs": "Math.abs",
    "floor": "Math.floor",
    "ceil": "Math.ceil",
    "round": "Math.round",
    "sqrt": "Math.sqrt",
    "pow": "Math.pow",
}


@dataclass
class JSGenerator:
    """Generates JavaScript code from parsed DSL modules."""

    vectorized: bool = False
    indent: str = "  "
    _depth: int = field(default=0, init=False)

    def generate(self, module: Module) -> str:
        """Generate JavaScript code for a module."""
        lines = []

        # Header comment
        lines.append("// Generated by Cosilico JS Generator")
        lines.append("// Do not edit manually")
        lines.append("")

        # Generate each variable as a function
        for var in module.variables:
            lines.append(self._generate_variable(var, module.references))
            lines.append("")

        # Export all variables
        var_names = [v.name for v in module.variables]
        lines.append(f"export {{ {', '.join(var_names)} }};")

        return "\n".join(lines)

    def _generate_variable(
        self, var: VariableDef, references: Optional[ReferencesBlock]
    ) -> str:
        """Generate a function for a variable definition."""
        lines = []

        # JSDoc comment
        if var.label or var.description:
            lines.append("/**")
            if var.label:
                lines.append(f" * {var.label}")
            if var.description:
                lines.append(f" * {var.description}")
            if var.reference:
                lines.append(f" * @see {var.reference}")
            lines.append(" */")

        # Function signature
        lines.append(f"function {var.name}(inputs, params) {{")

        # Generate formula body
        if var.formula:
            body = self._generate_formula(var.formula, references)
            for line in body.split("\n"):
                lines.append(f"{self.indent}{line}")
        else:
            # No formula - return default
            default = var.default if var.default is not None else 0
            lines.append(f"{self.indent}return {self._format_literal(default)};")

        lines.append("}")

        return "\n".join(lines)

    def _generate_formula(
        self, formula: FormulaBlock, references: Optional[ReferencesBlock]
    ) -> str:
        """Generate code for a formula block."""
        lines = []

        # Generate let bindings
        for binding in formula.bindings:
            value = self._generate_expression(binding.value, references)
            lines.append(f"const {binding.name} = {value};")

        # Generate return expression
        if formula.return_expr:
            expr = self._generate_expression(formula.return_expr, references)
            lines.append(f"return {expr};")
        else:
            # Implicit return of last binding or default
            lines.append("return 0;")

        return "\n".join(lines)

    def _generate_expression(
        self, expr: Expression, references: Optional[ReferencesBlock]
    ) -> str:
        """Generate JavaScript for an expression."""

        if isinstance(expr, Literal):
            return self._format_literal(expr.value)

        if isinstance(expr, Identifier):
            # Check if it's a reference alias
            if references and references.get_path(expr.name):
                # For now, just use the alias name as a variable
                return f"inputs.{expr.name}"
            return f"inputs.{expr.name}"

        if isinstance(expr, VariableRef):
            return f"{expr.name}(inputs, params)"

        if isinstance(expr, ParameterRef):
            if expr.index:
                return f"params['{expr.path}'][inputs.{expr.index}]"
            return f"params['{expr.path}']"

        if isinstance(expr, BinaryOp):
            left = self._generate_expression(expr.left, references)
            right = self._generate_expression(expr.right, references)
            op = BINARY_OPS.get(expr.op, expr.op)
            return f"({left} {op} {right})"

        if isinstance(expr, UnaryOp):
            operand = self._generate_expression(expr.operand, references)
            op = UNARY_OPS.get(expr.op, expr.op)
            return f"({op}{operand})"

        if isinstance(expr, FunctionCall):
            args = [self._generate_expression(arg, references) for arg in expr.args]
            func_name = BUILTIN_FUNCTIONS.get(expr.name, expr.name)
            return f"{func_name}({', '.join(args)})"

        if isinstance(expr, IfExpr):
            cond = self._generate_expression(expr.condition, references)
            then = self._generate_expression(expr.then_branch, references)
            else_ = self._generate_expression(expr.else_branch, references)
            return f"({cond} ? {then} : {else_})"

        if isinstance(expr, MatchExpr):
            return self._generate_match(expr, references)

        if isinstance(expr, LetBinding):
            # Inline let bindings in expressions
            value = self._generate_expression(expr.value, references)
            return value

        # Fallback
        return f"/* unknown expression: {type(expr).__name__} */ 0"

    def _generate_match(
        self, match: MatchExpr, references: Optional[ReferencesBlock]
    ) -> str:
        """Generate JavaScript for a match expression.

        Converts to chained ternary operators.
        """
        parts = []

        for case in match.cases:
            if case.condition is None:
                # else case
                value = self._generate_expression(case.value, references)
                parts.append(value)
            else:
                cond = self._generate_expression(case.condition, references)
                value = self._generate_expression(case.value, references)
                parts.append(f"({cond} ? {value} : ")

        # Close all the ternaries
        result = ""
        for i, part in enumerate(parts):
            if i < len(parts) - 1:
                result += part
            else:
                result += part + ")" * (len(parts) - 1)

        return result

    def _format_literal(self, value) -> str:
        """Format a literal value as JavaScript."""
        if value is True:
            return "true"
        if value is False:
            return "false"
        if value is None:
            return "null"
        if isinstance(value, str):
            # Escape quotes
            escaped = value.replace("\\", "\\\\").replace('"', '\\"')
            return f'"{escaped}"'
        if isinstance(value, (int, float)):
            return str(value)
        return str(value)


def generate_js(module: Module, vectorized: bool = False) -> str:
    """Generate JavaScript code from a parsed DSL module.

    Args:
        module: Parsed DSL module
        vectorized: If True, generate TypedArray-based vectorized code

    Returns:
        JavaScript source code as a string
    """
    generator = JSGenerator(vectorized=vectorized)
    return generator.generate(module)
